"""
NinjaTrader Export
==================
Generates NinjaScript code for NinjaTrader 8 automated strategy

Usage:
    from ninjatrader_export import NinjaTraderExporter
    
    exporter = NinjaTraderExporter()
    code = exporter.generate_strategy()
    exporter.save_to_file(code, 'MyStrategy.cs')
"""

import json
from datetime import datetime
from typing import Dict, Optional
from pathlib import Path


class NinjaTraderExporter:
    """
    Exports dual strategy to NinjaTrader 8 NinjaScript
    
    Generates complete C# code for:
    - Signal detection
    - Position sizing
    - Risk management
    - Order entry/exit
    """
    
    # Default strategy parameters
    DEFAULT_PARAMS = {
        'instrument': 'MNQ',
        'timeframe': '1 Minute',
        'session_start': '10:00',
        'session_end': '13:00',
        'delta_period': 20,
        'delta_threshold': 85,
        'imbalance_threshold': 85,
        'volume_spike_multiplier': 1.5,
        'atr_period': 14,
        'stop_multiplier': 0.4,
        'reward_multiplier': 2.0,
        'max_hold_bars': 8,
        'tier_1_size': 31,
        'tier_2_size': 15,
        'max_daily_loss': 2000,
        'max_consecutive_losses': 5,
    }
    
    def __init__(self, params: Optional[Dict] = None):
        """Initialize exporter with strategy parameters"""
        self.params = {**self.DEFAULT_PARAMS, **(params or {})}
    
    def generate_strategy(self, strategy_name: str = "DualOrderFlowStrategy") -> str:
        """
        Generate complete NinjaScript strategy code
        
        Returns:
            Complete C# code as string
        """
        code_parts = [
            self._generate_header(strategy_name),
            self._generate_usings(),
            self._generate_namespace_start(),
            self._generate_class_declaration(strategy_name),
            self._generate_variables(),
            self._generate_constructor(),
            self._generate_state_changed(),
            self._generate_on_bar_update(),
            self._generate_helper_methods(),
            self._generate_class_end(),
            self._generate_namespace_end()
        ]
        
        return '\n'.join(code_parts)
    
    def _generate_header(self, strategy_name: str) -> str:
        """Generate file header comment"""
        return f'''// {strategy_name}.cs
// Auto-generated by NinjaTraderExporter
// Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
//
// Dual Strategy System for MNQ (Micro Nasdaq)
// Strategy A: Imbalance + Volume + CVD (Tier 1)
// Strategy B: Delta + CVD (Tier 2)
//
// Configure parameters in NinjaTrader Strategy settings
'''
    
    def _generate_usings(self) -> str:
        """Generate using statements"""
        return '''
using System;
using System.Collections.Generic;
using System.Linq;
using NinjaTrader.Cbi;
using NinjaTrader.Gui;
using NinjaTrader.Gui.Chart;
using NinjaTrader.Gui.SuperDom;
using NinjaTrader.Data;
using NinjaTrader.NinjaScript;
using NinjaTrader.Core.FloatingPoint;
using NinjaTrader.NinjaScript.DrawingTools;
using System.Windows.Media;
'''
    
    def _generate_namespace_start(self) -> str:
        """Generate namespace start"""
        return '''
namespace NinjaTrader.NinjaScript.Strategies
{
'''
    
    def _generate_class_declaration(self, strategy_name: str) -> str:
        """Generate class declaration"""
        return f'''
    public class {strategy_name} : Strategy
    {{
'''
    
    def _generate_variables(self) -> str:
        """Generate private variables"""
        return '''
        #region Variables
        
        // Order flow data series
        private Series<double> deltaSeries;
        private Series<double> cvdSeries;
        private Series<double> imbalanceSeries;
        
        // Indicator variables
        private double atrValue;
        private double deltaPercentile;
        private double imbalancePercentile;
        private bool cvdRising;
        private bool volumeSpike;
        
        // Position tracking
        private int currentPositionSize;
        private int consecutiveLosses;
        private double dailyPnL;
        private DateTime lastTradeDate;
        
        // Order tracking
        private Order entryOrder;
        private Order stopOrder;
        private Order targetOrder;
        private int barsInTrade;
        
        #endregion
'''
    
    def _generate_constructor(self) -> str:
        """Generate constructor with default parameters"""
        return f'''
        public {self.__class__.__name__}()
        {{
            // Strategy configuration
            Name = "DualOrderFlowStrategy";
            Description = "Dual Tier Order Flow Strategy for MNQ";
            
            // Risk parameters
            MaximumBarsLookBack = MaximumBarsLookBack.Infinite;
            EntriesPerDirection = 1;
            EntryHandling = EntryHandling.AllEntries;
            
            // Initialize series
            deltaSeries = new Series<double>(this);
            cvdSeries = new Series<double>(this);
            imbalanceSeries = new Series<double>(this);
            
            // Initialize tracking
            consecutiveLosses = 0;
            dailyPnL = 0;
            barsInTrade = 0;
            lastTradeDate = DateTime.MinValue;
        }}
'''
    
    def _generate_state_changed(self) -> str:
        """Generate StateChange event handler"""
        return '''
        protected override void OnStateChange()
        {
            if (State == State.SetDefaults)
            {
                // Set default parameters
                AddChartIndicator(new OrderFlowCumulativeDelta(OrderFlowCumulativeDeltaType.BidAsk, OrderFlowCumulativeDeltaPeriod.Bar));
            }
            else if (State == State.Configure)
            {
                // Add data series if needed
            }
            else if (State == State.Historical)
            {
                // Historical data processing
            }
            else if (State == State.Realtime)
            {
                // Real-time trading
            }
        }
'''
    
    def _generate_on_bar_update(self) -> str:
        """Generate main OnBarUpdate method"""
        return '''
        protected override void OnBarUpdate()
        {
            // Skip first bars for indicators
            if (CurrentBar < 20)
                return;
            
            // Update daily tracking
            if (Time[0].Date != lastTradeDate.Date)
            {
                dailyPnL = 0;
                consecutiveLosses = 0;
                lastTradeDate = Time[0].Date;
            }
            
            // Calculate order flow features
            CalculateOrderFlowFeatures();
            
            // Check time window (10:00 - 13:00 ET)
            int currentTime = ToTime(Time[0]);
            if (currentTime < 100000 || currentTime > 130000)
                return;
            
            // Check risk limits
            if (!CanTrade())
                return;
            
            // Manage open position
            if (Position.MarketPosition != MarketPosition.Flat)
            {
                ManageOpenPosition();
                return;
            }
            
            // Check for entry signals
            CheckEntrySignals();
        }
'''
    
    def _generate_helper_methods(self) -> str:
        """Generate helper methods"""
        return '''
        #region Helper Methods
        
        private void CalculateOrderFlowFeatures()
        {
            // Calculate delta (ask volume - bid volume)
            double askVol = Volume[0].AskVolume;
            double bidVol = Volume[0].BidVolume;
            double delta = askVol - bidVol;
            deltaSeries[0] = delta;
            
            // Calculate delta percentile (last 20 bars)
            deltaPercentile = CalculatePercentile(deltaSeries, 20);
            
            // Calculate CVD (Cumulative Delta)
            if (CurrentBar == 0)
                cvdSeries[0] = delta;
            else
                cvdSeries[0] = cvdSeries[1] + delta;
            
            // CVD trend
            double cvdMA = SMA(cvdSeries, 20)[0];
            cvdRising = cvdSeries[0] > cvdMA;
            
            // Calculate imbalance
            double imbalance = askVol / Math.Max(bidVol, 1);
            imbalanceSeries[0] = EMA(imbalanceSeries, 5)[0]; // Smoothed
            imbalancePercentile = CalculatePercentile(imbalanceSeries, 20);
            
            // Volume spike
            double volMA = SMA(Volume, 20)[0];
            volumeSpike = Volume[0].TotalVolume > (volMA * 1.5);
            
            // ATR
            atrValue = ATR(14)[0];
        }
        
        private double CalculatePercentile(Series<double> series, int period)
        {
            if (CurrentBar < period)
                return 50;
            
            double currentValue = series[0];
            int count = 0;
            
            for (int i = 0; i < period; i++)
            {
                if (series[i] <= currentValue)
                    count++;
            }
            
            return (double)count / period * 100;
        }
        
        private bool CanTrade()
        {
            // Check daily loss limit
            if (dailyPnL <= -2000)
            {
                Draw.TextFixed(this, "RiskStop", "DAILY LOSS LIMIT REACHED", TextPosition.TopLeft, Brushes.Red);
                return false;
            }
            
            // Check consecutive losses
            if (consecutiveLosses >= 5)
            {
                Draw.TextFixed(this, "RiskStop", "MAX CONSECUTIVE LOSSES", TextPosition.TopLeft, Brushes.Red);
                return false;
            }
            
            return true;
        }
        
        private void CheckEntrySignals()
        {
            bool signalALong = false, signalAShort = false;
            bool signalBLong = false, signalBShort = false;
            
            // Strategy A: Imbalance + Volume + CVD
            if (imbalancePercentile > 85 && volumeSpike)
            {
                if (cvdRising && deltaSeries[0] > 0)
                    signalALong = true;
                else if (!cvdRising && deltaSeries[0] < 0)
                    signalAShort = true;
            }
            
            // Strategy B: Delta + CVD
            if (deltaPercentile > 85)
            {
                if (cvdRising && deltaSeries[0] > 0 && !signalALong)
                    signalBLong = true;
                else if (!cvdRising && deltaSeries[0] < 0 && !signalAShort)
                    signalBShort = true;
            }
            
            // Execute trades
            if (signalALong)
            {
                EnterLongPosition(31, "Strategy A Long");
            }
            else if (signalAShort)
            {
                EnterShortPosition(31, "Strategy A Short");
            }
            else if (signalBLong)
            {
                EnterLongPosition(15, "Strategy B Long");
            }
            else if (signalBShort)
            {
                EnterShortPosition(15, "Strategy B Short");
            }
        }
        
        private void EnterLongPosition(int quantity, string label)
        {
            double stopDist = atrValue * 0.4;
            double targetDist = stopDist * 2.0;
            
            double entryPrice = Close[0];
            double stopPrice = entryPrice - stopDist;
            double targetPrice = entryPrice + targetDist;
            
            // Enter with OCO bracket
            EnterLong(quantity, label);
            SetStopLoss(label, CalculationMode.Price, stopPrice, false);
            SetProfitTarget(label, CalculationMode.Price, targetPrice, false);
            
            currentPositionSize = quantity;
            barsInTrade = 0;
            
            Draw.ArrowUp(this, label + CurrentBar, false, "Entry", 0);
        }
        
        private void EnterShortPosition(int quantity, string label)
        {
            double stopDist = atrValue * 0.4;
            double targetDist = stopDist * 2.0;
            
            double entryPrice = Close[0];
            double stopPrice = entryPrice + stopDist;
            double targetPrice = entryPrice - targetDist;
            
            // Enter with OCO bracket
            EnterShort(quantity, label);
            SetStopLoss(label, CalculationMode.Price, stopPrice, false);
            SetProfitTarget(label, CalculationMode.Price, targetPrice, false);
            
            currentPositionSize = quantity;
            barsInTrade = 0;
            
            Draw.ArrowDown(this, label + CurrentBar, false, "Entry", 0);
        }
        
        private void ManageOpenPosition()
        {
            barsInTrade++;
            
            // Time exit after 8 bars
            if (barsInTrade >= 8)
            {
                if (Position.MarketPosition == MarketPosition.Long)
                    ExitLong("Time Exit");
                else if (Position.MarketPosition == MarketPosition.Short)
                    ExitShort("Time Exit");
                
                return;
            }
        }
        
        protected override void OnPositionUpdate(Position position, double averagePrice,
            int quantity, MarketPosition marketPosition)
        {
            if (position.MarketPosition == MarketPosition.Flat)
            {
                // Position closed - calculate P&L
                double tradePnL = position.GetProfitLoss(Close[0], PerformanceUnit.Currency);
                dailyPnL += tradePnL;
                
                // Track consecutive losses
                if (tradePnL < 0)
                    consecutiveLosses++;
                else
                    consecutiveLosses = 0;
                
                // Draw exit marker
                if (tradePnL > 0)
                    Draw.Diamond(this, "Exit" + CurrentBar, false, "Profit", 0, Brushes.Green);
                else
                    Draw.Diamond(this, "Exit" + CurrentBar, false, "Loss", 0, Brushes.Red);
            }
        }
        
        protected override void OnOrderUpdate(Order order, double limitPrice, double stopPrice,
            int quantity, int filled, double averageFillPrice, OrderState orderState,
            DateTime time, ErrorCode error, string nativeError)
        {
            // Track order status
            if (orderState == OrderState.Filled)
            {
                // Order filled
            }
            else if (orderState == OrderState.Cancelled)
            {
                // Order cancelled
            }
        }
        
        #endregion
'''
    
    def _generate_class_end(self) -> str:
        """Generate class closing"""
        return '''
    }
'''
    
    def _generate_namespace_end(self) -> str:
        """Generate namespace closing"""
        return '''}
'''
    
    def generate_atm_strategy(self, atm_name: str = "DualStrategyATM") -> str:
        """
        Generate ATM (Advanced Trade Management) strategy XML
        
        Returns:
            ATM strategy XML as string
        """
        return f'''<?xml version="1.0" encoding="utf-16"?>
<AtmStrategy xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
  <Name>{atm_name}</Name>
  <StopTargetHandling>OCO</StopTargetHandling>
  <Strategies>
    <AtmStrategyInstrument>
      <StopTarget>
        <IsStopEnabled>true</IsStopEnabled>
        <IsTargetEnabled>true</IsTargetEnabled>
        <TargetPrice>2.0</TargetPrice>
        <StopPrice>1.0</StopPrice>
        <TargetType>Multiplier</TargetType>
        <StopType>Multiplier</StopType>
      </StopTarget>
      <Quantity>31</Quantity>
      <TimeInForce>Gtc</TimeInForce>
      <OrderType>Limit</OrderType>
    </AtmStrategyInstrument>
  </Strategies>
</AtmStrategy>
'''
    
    def save_to_file(self, code: str, filepath: str):
        """
        Save generated code to file
        
        Args:
            code: Generated code string
            filepath: Path to save file
        """
        path = Path(filepath)
        path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(path, 'w') as f:
            f.write(code)
        
        print(f"Saved to: {filepath}")
    
    def export_all(self, output_dir: str = './ninjatrader_export'):
        """
        Export all files to directory
        
        Creates:
        - Strategy.cs
        - ATM_Strategy.xml
        - parameters.json
        """
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)
        
        # Export strategy
        strategy_code = self.generate_strategy()
        self.save_to_file(strategy_code, output_path / 'DualOrderFlowStrategy.cs')
        
        # Export ATM
        atm_code = self.generate_atm_strategy()
        self.save_to_file(atm_code, output_path / 'DualStrategyATM.xml')
        
        # Export parameters
        params_file = output_path / 'parameters.json'
        with open(params_file, 'w') as f:
            json.dump(self.params, f, indent=2)
        
        print(f"\nExported to: {output_dir}")
        print("Files created:")
        print("  - DualOrderFlowStrategy.cs (Main strategy)")
        print("  - DualStrategyATM.xml (ATM template)")
        print("  - parameters.json (Configuration)")


# Installation instructions
INSTALLATION_GUIDE = '''
NinjaTrader Installation Guide
==============================

1. Copy Files:
   - Copy "DualOrderFlowStrategy.cs" to:
     Documents\\NinjaTrader 8\\bin\\Custom\\Strategies\\

2. Copy ATM Strategy:
   - Copy "DualStrategyATM.xml" to:
     Documents\\NinjaTrader 8\\templates\\AtmStrategy\\

3. Compile Strategy:
   - Open NinjaTrader 8
   - Go to Tools > Edit NinjaScript > Strategy
   - Press F5 to compile
   - Check for errors in the NinjaScript Output window

4. Configure Strategy:
   - Open a chart (MNQ, 1-minute)
   - Right-click > Strategies
     - Add "DualOrderFlowStrategy"
   - Configure parameters in the strategy panel
   - Enable the strategy

5. Enable Automated Trading:
   - Ensure you have a data feed connected
   - Check "Automated Trading Execution" in Control Center
   - Set proper account position limits
   - Test in simulation mode first!

6. ATM Strategy:
   - When strategy generates signal, it will use the ATM template
   - Go to Control Center > Tools > Account Performance
   - Monitor trades in the Orders tab

Important:
- Always test in simulation mode first
- Use "Playback" for historical testing
- Monitor first week closely
- Have manual override ready
'''


def main():
    """Main function for command-line usage"""
    exporter = NinjaTraderExporter()
    
    print("NinjaTrader Export Tool")
    print("=" * 50)
    print("\nGenerating strategy files...\n")
    
    exporter.export_all()
    
    print("\n" + INSTALLATION_GUIDE)


if __name__ == '__main__':
    main()
